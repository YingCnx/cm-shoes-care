import pool from "../config/database.js";

  class Queue {

   // ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Queue ‡πÉ‡∏´‡∏°‡πà
   static async create({customer_id, customer_name, phone, location, total_pairs, total_price = 0,received_date, delivery_date, branch_id,source,locker_id,slot_id }) {
    try {
        const result = await pool.query(
            `INSERT INTO queue (customer_id,customer_name, phone, location, total_pairs, total_price, delivery_date, branch_id, status, received_date, source, locker_id, slot_id) 
             VALUES ($1, $2, $3, $4, $5, $6, $7,$8, '‡∏£‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤', $9, $10, $11, $12) 
             RETURNING id`, // ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤ column ‡∏ó‡∏µ‡πà‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡∏£‡∏ö
            [customer_id,customer_name, phone, location, total_pairs, total_price, delivery_date, branch_id,received_date,source,locker_id,slot_id]
        );
        return result.rows[0].id; // ‚úÖ Return queue_id
    } catch (error) {
        throw new Error(`üî¥ Error creating queue: ${error.message}`);
    }
}
  


  // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡∏¥‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• services
  static async getAll() {
    try {
        const result = await pool.query(`
           SELECT 
                q.id AS queue_id, 
                c.name AS customer_name, 
                c.phone, 
                q.location, 
                q.total_pairs, 
                q.total_price, 
                q.delivery_date, 
                q.status, 
                q.received_date,
                q.payment_status,
                json_agg(
                    json_build_object(
                        'service_id', qi.service_id,
                        'service_name', s.service_name,
                        'price_per_pair', qi.price_per_pair
                    )
                ) FILTER (WHERE qi.service_id IS NOT NULL) AS services
            FROM queue q
            LEFT JOIN customers c ON q.customer_id = c.id
            LEFT JOIN queue_items qi ON q.id = qi.queue_id
            LEFT JOIN services s ON qi.service_id = s.id
            GROUP BY q.id, c.name, c.phone
            ORDER BY q.delivery_date ASC NULLS LAST;

        `);
        return result.rows;
    } catch (error) {
        throw new Error(`üî¥ Error fetching queue: ${error.message}`);
    }
  }

  static async getByBranch(branch_id) {
    try {
        const result = await pool.query(`
            SELECT 
          q.id AS queue_id, 
          c.name AS customer_name, 
          c.phone, 
          q.location, 
          q.total_pairs, 
          q.total_price, 
          q.delivery_date, 
          q.status, 
          q.received_date,
          q.payment_status,
          q.source,             -- ‚úÖ ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô locker, facebook, ‡∏Ø‡∏•‡∏Ø
          q.return_slot_id,     -- ‚úÖ ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô
          q.locker_id,          -- ‚úÖ ‡∏£‡∏´‡∏±‡∏™‡∏ï‡∏π‡πâ
          q.slot_id,            -- ‚úÖ ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤
          json_agg(
              json_build_object(
                  'service_id', qi.service_id,
                  'service_name', s.service_name,
                  'price_per_pair', qi.price_per_pair
              )
          ) FILTER (WHERE qi.service_id IS NOT NULL) AS services
      FROM queue q
      LEFT JOIN customers c ON q.customer_id = c.id
      LEFT JOIN queue_items qi ON q.id = qi.queue_id
      LEFT JOIN services s ON qi.service_id = s.id
      WHERE q.branch_id = $1  AND q.status != '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
      GROUP BY 
          q.id, 
          c.name, 
          c.phone,
          q.source,
          q.return_slot_id,
          q.locker_id,
          q.slot_id
      ORDER BY q.delivery_date ASC NULLS LAST;

        `, [branch_id]);  // ‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤ branch_id ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Query
        return result.rows;
    } catch (error) {
        throw new Error(`üî¥ Error fetching queue: ${error.message}`);
    }
}


   // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡∏¥‡∏ß‡∏ï‡∏≤‡∏° ID ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤
   static async getById(id) {
    try {
      if (isNaN(id)) {
        throw new Error("Invalid Queue ID");
      }

      const queueResult = await pool.query(
        `
           SELECT 
              q.id AS queue_id, 
              q.id AS id,                          -- ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° id ‡πÄ‡∏â‡∏¢ ‡πÜ ‡∏î‡πâ‡∏ß‡∏¢ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ frontend ‡πÉ‡∏ä‡πâ queue.id ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
              q.customer_id,                       -- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö appointment
              q.branch_id,                         -- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö appointment
              c.name AS customer_name,            -- ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠
              c.phone,                            -- ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ö‡∏≠‡∏£‡πå
              q.location, 
              q.total_pairs, 
              q.total_price, 
              q.delivery_date, 
              q.status, 
              q.received_date,
              q.payment_status,
              q.source,                            -- ‚úÖ ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏≤‡∏á
              l.code AS locker_code,              -- ‚úÖ ‡∏£‡∏´‡∏±‡∏™‡∏ï‡∏π‡πâ
              l.name AS locker_name,              -- ‚úÖ ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏π‡πâ
              q.slot_id,         
              b.name AS branch_name,              -- ‚úÖ ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏Ç‡∏≤
              json_agg(
                  json_build_object(
                      'service_id', qi.service_id,
                      'service_name', s.service_name,
                      'price_per_pair', qi.price_per_pair
                  )
              ) FILTER (WHERE qi.service_id IS NOT NULL) AS services
          FROM queue q
          LEFT JOIN customers c ON q.customer_id = c.id
          LEFT JOIN queue_items qi ON q.id = qi.queue_id
          LEFT JOIN services s ON qi.service_id = s.id
          LEFT JOIN branches b ON q.branch_id = b.id
          LEFT JOIN lockers l ON q.locker_id = l.id  
          WHERE q.id = $1
          GROUP BY q.id, q.customer_id, q.branch_id, c.name, c.phone, b.name, q.source, l.code, l.name, q.slot_id
          ORDER BY q.delivery_date ASC NULLS LAST;
        `, [id]);  

      if (queueResult.rows.length === 0) {
        throw new Error(`Queue ID ${id} not found`);
      }

      const queueData = queueResult.rows[0];

      // ‚úÖ ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£ + ‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤‡πÉ‡∏ô queue_items
      const itemsResult = await pool.query(
        `SELECT qi.id AS queue_item_id, qi.service_id, s.service_name, qi.price_per_pair, 
                qi.brand, qi.model, qi.color, qi.notes,
                qi.image_before_front, qi.image_before_back, qi.image_before_left, qi.image_before_right, qi.image_before_top, qi.image_before_bottom,
                qi.image_after_front, qi.image_after_back, qi.image_after_left, qi.image_after_right, qi.image_after_top, qi.image_after_bottom
         FROM queue_items qi
         LEFT JOIN services s ON qi.service_id = s.id
         WHERE qi.queue_id = $1`, 
        [id]
      );

      queueData.queue_items = itemsResult.rows.length > 0 ? itemsResult.rows : [];

      return queueData;
    } catch (error) {
      throw new Error(`üî¥ Error fetching queue by ID: ${error.message}`);
    }
  }

// üìå ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏¥‡∏ß
  static async updatePaymentStatus(queue_id, status) {
    try {
        const result = await pool.query(
            "UPDATE queue SET payment_status = $1 WHERE id = $2 RETURNING *",
            [status, queue_id]
        );

        return result.rows[0] || null;
    } catch (error) {
        console.error("üî¥ Error updating payment status:", error);
        throw error;
    }
  }

// ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏¥‡∏ß ‡∏û‡∏£‡πâ‡∏≠‡∏° delivery_method
static async updateStatus(id, status, total_price = null, delivery_method = null) {
  try {
    if (status === "‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡πà‡∏á" && (!total_price || isNaN(total_price))) {
      throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô '‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡πà‡∏á'");
    }

    const finalPrice = total_price !== null && !isNaN(total_price) ? total_price : 0;

    // ‚úÖ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° SQL ‡πÅ‡∏•‡∏∞ parameters
    const updateFields = ['status = $1', 'total_price = $2'];
    const values = [status, finalPrice];

    // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ delivery_method ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ SQL
    if (delivery_method && typeof delivery_method === 'string') {
      updateFields.push('delivery_method = $3');
      values.push(delivery_method.toLowerCase());
    }
    
    const sql = `UPDATE queue SET ${updateFields.join(', ')} WHERE id = $${values.length + 1}`;
    values.push(id);

    await pool.query(sql, values);

    return { message: "‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏¥‡∏ß‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!" };
  } catch (error) {
    throw new Error(`üî¥ Error updating queue status: ${error.message}`);
  }
}


static async updateStatusbyAppointment(id, status) {
  try {
    const result = await pool.query(
      "UPDATE queue SET status = $1 WHERE id = $2 RETURNING *",
      [status, id] 
    );

    return result.rows[0] || null;
  } catch (error) {
    console.error("üî¥ Error updating queue status:", error);
    throw error;
  }
}




  // ‚úÖ ‡∏•‡∏ö‡∏Ñ‡∏¥‡∏ß (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à)
static async delete(id) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // 1Ô∏è‚É£ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï locker_drop ‡πÉ‡∏´‡πâ queue_id = null ‡∏Å‡πà‡∏≠‡∏ô
    await client.query(`UPDATE locker_drop SET queue_id = NULL WHERE queue_id = $1`, [id]);

    // 2Ô∏è‚É£ ‡∏•‡∏ö queue ‡∏ñ‡πâ‡∏≤ status ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà '‡∏à‡∏±‡∏î‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
    await client.query(`DELETE FROM queue WHERE id = $1 AND status != '‡∏à‡∏±‡∏î‡∏™‡πà‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'`, [id]);

    await client.query('COMMIT');
    return { message: "‚úÖ Queue deleted successfully!" };
  } catch (error) {
    await client.query('ROLLBACK');
    throw new Error(`üî¥ Error deleting queue: ${error.message}`);
  } finally {
    client.release();
  }
}

// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ queue ‡πÄ‡∏õ‡πá‡∏ô "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å" ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö
static async cancel(id) {
  try {
    const result = await pool.query(
      "UPDATE queue SET status = '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å' WHERE id = $1 RETURNING *",
      [id]
    );

    return result.rows[0] || null;
  } catch (error) {
    console.error("üî¥ Error cancelling queue:", error);
    throw error;
  }
}

  //‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤
  static async updateTotalPairs(queue_id, total_pairs) {
    return await pool.query(
      `UPDATE queue SET total_pairs = $1 WHERE id = $2`,
      [total_pairs, queue_id]
    );
  }

  static async updateTotalPairsAndPrice(queue_id) {
    try {
        const result = await pool.query(
            `UPDATE queue 
            SET total_pairs = (SELECT COUNT(*) FROM queue_items WHERE queue_id = $1),
                total_price = (
                    COALESCE((SELECT SUM(price_per_pair) FROM queue_items WHERE queue_id = $1), 0) + 
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE queue_id = $1), 0)
                )
            WHERE id = $1 RETURNING *;`,
            [queue_id]
        );
        return result.rows[0]; // ‚úÖ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Queue ‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
    } catch (error) {
        throw new Error(`üî¥ Error updating total_pairs and total_price: ${error.message}`);
    }
}


  // ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï queue_id ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
  static async updateQueueId(appointment_id, queue_id) {
    try {
        const result = await pool.query(
            `UPDATE appointments SET queue_id = $1 WHERE id = $2 RETURNING *`,
            [queue_id, appointment_id]
        );
        return result.rows[0];
    } catch (error) {
        throw new Error(`üî¥ Error updating appointment queue_id: ${error.message}`);
    }
  }

  static async updateQueue(id, location, total_pairs, received_date, delivery_date) {
    try {
      const result = await pool.query(
        `UPDATE queue SET location = $1, total_pairs = $2, received_date = $3, delivery_date = $4 WHERE id = $5 RETURNING *`,
        [location, total_pairs, received_date, delivery_date, id]
      );  
      return result.rows[0];
      } catch (error) {
        throw new Error(`üî¥ Error updating queue: ${error.message}`);
      }
    }

      // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡∏¥‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ locker_id ‡∏ô‡∏µ‡πâ
  static async getByLockerId(lockerId) {
    const result = await pool.query(
      `SELECT * FROM queue WHERE locker_id = $1`,
      [lockerId]
    );
    return result.rows;
  }

}


  // ‚úÖ ‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏¥‡∏ß‡∏à‡∏≤‡∏Å‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£
  export async function getQueueStatusByPhone(phone) {
    const result = await pool.query(
        "SELECT status FROM queue WHERE phone = $1 ORDER BY received_date DESC LIMIT 1",
        [phone]
    );
    return result.rows.length ? `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ${result.rows[0].status}` : null;
  }

  // ‚úÖ ‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏¥‡∏ß‡∏à‡∏≤‡∏Å‡∏£‡∏´‡∏±‡∏™‡∏Ñ‡∏¥‡∏ß
  export async function getQueueStatusById(queue_id) {
    const result = await pool.query(
        "SELECT status FROM queue WHERE id = $1",
        [queue_id]
    );
    return result.rows.length ? `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ${result.rows[0].status}` : null;
  }


    
  //‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
  export const getMonthlyRevenue = async () => {
    try {
        const [rows] = await db.execute(`
            SELECT SUM(total_amount) AS revenue 
            FROM payments
            WHERE EXTRACT(MONTH FROM payment_date) = EXTRACT(MONTH FROM CURRENT_DATE)
            AND EXTRACT(YEAR FROM payment_date) = EXTRACT(YEAR FROM CURRENT_DATE)
        `);
        return rows[0].revenue || 0;
    } catch (error) {
        throw error;
    }
};






export default Queue;
